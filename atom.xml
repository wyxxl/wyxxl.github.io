<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Tangle</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-03-28T06:34:26.836Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>tangle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈智能物联网家居平台安全隐患</title>
    <link href="http://example.com/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/"/>
    <id>http://example.com/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/</id>
    <published>2022-11-27T01:29:30.000Z</published>
    <updated>2023-03-28T06:34:26.836Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01.简介"></a>0x01.简介</h2><p>随着物联网云的兴起，越来越多的智能设备接入了云。现在人们可以随时随地拿起手机，打开APP远程控制家里的路由器、摄像机、扫地机等等。但这种前所未有的便利也引入了各种安全隐患。笔者最近在usenix上读到一篇关于智能物联网家居平台安全隐患的论文：”Discovering and Understanding the Security Hazards in  the Interactions between IoT Devices, Mobile Apps, and  Clouds on Smart Home Platforms”，本文以这篇论文为主线，聊聊智能物联网家居平台的安全隐患。</p><h2 id="0x02-智能物联网平台"><a href="#0x02-智能物联网平台" class="headerlink" title="0x02.智能物联网平台"></a>0x02.智能物联网平台</h2><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221109170851434.png" alt="image-20221109170851434"></p><p>如图所示基于云的智能家居平台，涉及三个关键的相互交互的对象：物联网设备、移动应用程序和物联网云。<br>物联网云是智能家居平台的大脑，用于设备识别管理、设备控制等。传统嵌入式设备一般通过嵌入式web服务来管理，比如用户通过浏览器访问路由器、摄像机的http服务，输入用户名、密码登录管理。随着移动互联网的发展，很多IoT设备接入了云，同时使用移动应用来管理设备，移动应用程序将输入请求发送到物联网云，物联网云再将请求下发到IoT设备，这类设备自身可能没有直接对外开放的端口服务，但也引入了一些新的攻击面。</p><h2 id="0x03-智能设备交互概览"><a href="#0x03-智能设备交互概览" class="headerlink" title="0x03.智能设备交互概览"></a>0x03.智能设备交互概览</h2><p>1.设备发现和WiFi配置：物联网设备需要加入与移动应用程序相同的局域网，用户通过指定的移动应用APP“添加设备”按钮通过广播发送消息或通过设备的接入点与设备连接，设备上报其基本信息，如MAC地址和设备型号给到移动应用程序，同时通过移动应用程序给设备配网，使得IoT设备能够访问物联网云。</p><p>2.设备注册：设备注册后，物联网设备被赋予一个唯一的设备 ID。不同类型的平台以不同的方式提供设备 ID。对于 I 类平台，设备将其设备身份信息发送到它所属的物联网云，云然后生成一个设备ID 并将其返回给设备，云端还保留了一个设备 ID 记录以供将来验证。对于 II 型平台，设备的设备 ID 由平台事先硬编码到设备。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221109184838323.png" alt="image-20221109184838323"></p><p>3.设备绑定：移动应用账户和设备直接建立绑定关系，只有授权用户可以通过云端访问设备。对于Type I平台，绑定请求直接由移动应用程序发送到物联网云，由物联网云负责维护绑定信息并执行权限检查（即用户帐户是否具有访问设备的权限）。对于 Type II 平台，移动应用程序首先将帐户信息发送到设备，有了设备 ID 和用户帐户，设备向物联网云发出绑定请求。</p><p>4.设备登录：设备使用自己的设备ID登录物联网云。然后它与云以保持状态更新并准备好执行远程命令。另外，当设备长时间失去与云端的连接时，它会尝试自动地重新登录。</p><p>5.使用中的设备：注册登录成功后， 设备执行设计的功能，通过移动应用程序远程控制设备。</p><p>6.设备解绑和重置：当用户不再使用该设备，可以解除绑定或重置它。 当用户请求解绑时，对于 I 类平台， 物联网云直接擦除绑定信息。对于II类平台，因为设备本地也存有绑定信息，解绑请求从云端下发到设备擦除绑定信息。</p><h2 id="0x04-威胁模型评估"><a href="#0x04-威胁模型评估" class="headerlink" title="0x04.威胁模型评估"></a>0x04.威胁模型评估</h2><p>这里文中假设攻击者有能力收集必要的信息，包括设备身份信息和合法性信息。针对不同的平台，收集这些信息项的难度不同。根据获取特定身份信息项的方式，可以对这些信息项进行分类分为三类：公共信息（P）、可猜测信息（G）和硬编码信息（H）。例如，设备型号和设备芯片id (CID) 是公共信息，可猜测的信息是指能够被暴力猜解的，比如MAC 地址就是一种典型的可猜测的信息。硬编码的信息是指不易预测的、不可变的，并且设备固有的。例如，嵌入在设备硬件中设备 ID 是 Type II 平台的一种典型的硬编码信息。此外，对于某些Type I 平台，硬编码信息（例如，序列号(SN)) 也包含在设备 ID 的生成中。虽然硬编码的信息不容易获得，但它是不变的，一旦这些信息泄露，受害者设备将存在潜在风险。要获取这些信息，攻击者可以通过嗅探设备应用流量或进入设备shell等方式来获取设备的硬编码设备 ID，另外二手平台上售卖的设备或公寓酒店的设备ID信息也可能会被攻击者恶意收集。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221110141238574.png" alt="image-20221110141238574"></p><p>实际上论文中提到的类似Alink平台使用MAC地址来标识设备的厂商并不少见，这种做法存在被攻击的风险，物联网云将MAC地址作为与真实设备的映射，而MAC地址是一种典型的可被猜测的信息，MAC地址前3字节表示OUI（Organizationally Unique Identifier），是<a href="https://baike.baidu.com/item/IEEE/150905">IEEE</a>的注册管理机构给不同厂家分配的代码，区分不同的厂家。后3字节由厂家自行分配，假如攻击者有一台设备，通过这台设备MAC地址就可以猜解出其他同型号设备的MAC地址，前三字节固定，遍历后三个字节即可。</p><p>通过MAC地址前三个字节查询对应生成厂商：</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221110142315507.png" alt="image-20221110142315507"></p><p>这种直接使用MAC地址作为真实设备标识可能带来哪些危害？想象这么一个攻击场景，，用户使用移动应用与设备通信获取到设备MAC地址，然后向云端发送绑定请求，云端留存用户信息和MAC地址的绑定映射关系，然后用户通过移动应用远程控制该设备。这里关键点是移动应用程序通过这种方式向云端发送的绑定请求这个过程存在被攻击的风险，攻击者通过抓包获取到该请求，将其中的MAC地址参数替换，通过暴力猜解MAC地址的方式持续向物联网云发送绑定请求，最终攻击者可非法绑定大量设备，实际上一些设备同时只允一个用户绑定，但这种攻击也可以针对未出货的设备和已被解绑的设备，当用户买到一个新设备时可能已经被攻击者绑定过了。</p><p>一个产品整体的安全性和往往和开发者的安全意识有很大关系，国内很多应用都上了加固和通信强加密，但这也不代表可以和安全划等号。比如一款智能设备的移动应用程序和物联网云通信用了https、证书校验、请求体AES加密、加密后又压缩，应用做了加固、反调试等，实际上这些安全措施只是提高了逆向的门槛，并不能实际消除漏洞。当攻击者一层层扒开这些安全防护后就暴漏了协议设计本身，就如上述所说的非法绑定漏洞，本质是协议设计的漏洞。</p><h2 id="0x05-已识别的设计缺陷"><a href="#0x05-已识别的设计缺陷" class="headerlink" title="0x05.已识别的设计缺陷"></a>0x05.已识别的设计缺陷</h2><p>论文中对物联网云、设备、移动应用程序在不同时期的状态做了一个总结，围绕它们三者的状态组合，总结出来一些攻击向量并验证。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221110161405080.png" alt="image-20221110161405080"></p><p>在五个平台中共发现了四种缺陷：</p><p><strong>F1: Insufficient State Guard</strong>。实验发现这些平台对三个实体都没能够正确地处理它们的states。这可能导致严重后果。由于物联网云负责设备识别管理等安全关键服务，因此物联网云受到的影响最大。在物联网云的状态机中（Figure 2a），当云工作时处在状态 4（Running）中，理想情况下它应该只接受已授权用户请求（edge 6）或设备解除绑定请求（edge3）。但实际测试中发现物联网云也接受其他请求。根据物联网云处于状态 4 时正确接受的请求，将缺陷F1分解为三个子缺陷：</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221110172759999.png" alt="image-20221110172759999"></p><p>F1.1：这个缺陷是特定于 I 型平台的。拥有所有设备识别信息的攻击者可以使用虚拟设备向云端发送注册请求。（Figure 3F1.1）。<br>F1.2：此缺陷特定于 Type II 平台。 攻击者可以使用虚拟设备发送绑定请求将设备（由设备 ID 标识）与攻击者的帐户相关联（Figure 3F1.2）。在 II 型平台中的设备，绑定请求是从设备发出，云无条件接受绑定请求。结果，虚拟设备可以将攻击者的帐户绑定到受害者设备。<br>F1.3：物联网云接受设备登录请求，并将相应的设备ID返回给攻击者，即使它处于状态 4。</p><p><strong>F2： Illegal State Combination</strong>。实验发现这三个实体有时会处于意想不到的非法状态组合中。当一个非法的状态组合被利用时，安全可能会被破坏。例如，理想情况下，当用户重置并取消绑定设备，三个实体都应回到它们的初始状态（即状态组合（S1，S1，S1））。但是，对于 I 型平台，如果用户在没有重新设置设备的情况下解绑设备，设备仍然保留与云的连接，并且状态组合实际上切换到（S1，S4，S1），由于该设备处于这种非法状态组合，如果攻击者远程发出注册该设备的请求，请求被允许，云转移到状态 2。如果攻击者继续发送请求绑定设备，云接受请求并转移到状态4（状态3被跳过，因为连接仍然与受害者设备一起维护）。此时，如果攻击者向设备发送控制命令，云端将错误地将命令转发到被解绑的设备。这个本质上会导致设备劫持攻击。</p><p><strong>F3: Unauthorized Device Login。</strong>设备登录后，设备与物联网云之间保持连接。理想情况下，云应该只允许绑定的设备的帐户发出的登录请求。但是，实验发现物联网云在设备登录期间没有进行任何基于账户的授权检查。</p><p><strong>F4: Unauthorized Device Unbinding</strong>。理想情况下，只有拥有当前绑定到设备的用户有解除绑定设备的权限。如果解除绑定，一般在移动应用程序上进行，解除绑定请求中包含用户凭据。但对于Type I平台，发现也可以在设备端实现设备解绑。根据分析，设备端取消绑定命令不包含任何用户凭据。作为结果，攻击者可以构建一个虚拟设备使用设备端 API 伪造解绑请求，然后在用户不知情的情况下设备被解绑（Figure 3F4）。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221110184647717.png" alt="image-20221110184647717"></p><h2 id="0x06-漏洞利用"><a href="#0x06-漏洞利用" class="headerlink" title="0x06.漏洞利用"></a>0x06.漏洞利用</h2><p>论文中利用各种组合缺陷，验证了一系列攻击，包括远程设备替换、远程设备 DoS、非法设备占用。</p><p>文中实验使用 Alink 设备（Philips smart plug with model SPS9011A）和一个 TP-LINK 设备（WiFi Bulb with model LB110) 分别代表 I 型和 II 型设备，然后设法获得它们的身份和合法信息，Alink 设备使用型号、MAC 和 CID 作为其身份信息。型号和 CID，对于特定的设备类型是固定的，相应移动应用程序维护的日志中可以提取它们。对于 MAC 地址，上文已经提到过可以使用暴力破解。对于 TP-LINK 设备，由于其身份信息（即设备 ID）和合法性信息（即 hwid 和MAC 地址）是硬编码的，必须物理提取它们。具体来说，实验收集了设备 ID、hwid 和MAC 地址通过发起 MITM 攻击来拦截设备-应用程序通信。有了所有可用的所需信息，可以使用Python构建虚拟设备，即用Python程序模拟设备行为。</p><h3 id="6-1-远程设备替换"><a href="#6-1-远程设备替换" class="headerlink" title="6.1 远程设备替换"></a>6.1 远程设备替换</h3><p>这里展示了攻击者如何使用虚拟设备远程替换受害者的设备。下文使用 Alice 来表示受害者&#x2F;合法用户，Trudy 表示攻击者。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221114103126198.png" alt="image-20221114103126198"></p><p>在Figure5 的顶部（最高的红色虚线上方），展示了正常的工作流程，Alice 在 Type I 平台上使用她的 IoT 设备。在 Alice 为设备提供 WiFi 凭据后，设备将其合法性凭证和设备身份信息发送到云端以进行注册（步骤 A.1）。基于设备身份信息，云端用设备 ID A 注册设备并将其绑定到 Alice 的帐户（步骤A2）。设备登录后（步骤 A.3），Alice 可以控制她帐户下的设备。然后，攻击者 Trudy 进入，如图中间部分所示（在两条红色虚线之间），他先让虚拟设备发送相同的设备注册请求，由于缺陷 F1.1，云接受此请求并注册具有相同的设备 ID A的虚拟设备，但设备 ID A 仍保持与Alice的绑定，那么Trudy可以利用缺陷 F1.3 和 F3 在没有 Alice 账户信息的情况下登录虚拟设备。由于虚拟设备与真实设备具有相同的设备ID，云与真实设备断开了连接并与虚拟设备建立连接。但是，当真实设备在一段时间内没有收到心跳包，它会再次自动登录到上云并使虚拟设备脱机。相当于真实设备和虚拟设备在竞争与云的连接，攻击者Trudy可以将虚拟设备设置频繁登录，结果就是虚拟设备总能“挤掉”真实设备。 </p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221114110000032.png" alt="image-20221114110000032">同样，Figure6 的顶部（最高红色虚线上方）显示正常情况下Alice 如何在 Type II 平台上使用她的设备的工作流程。移动应用程序将她的帐户信息发送到设备（步骤A.1），设备发送绑定请求将设备 ID 和合法性信息以及帐户信息发送到云端（步骤 A.2）。云将设备 ID A绑定 到 Alice 的帐户。设备登录到云（步骤 A.3），Alice 可以使用移动应用程序控制&#x2F;监控设备。图中中间（两条红色虚线之间行)，Trudy 发起远程设备替换攻击。由于缺陷 F1.3 和 F3 ，他让虚拟设备使用相同的设备ID成功登录云端。此时，设备 ID A 仍然绑定到 Alice 的帐户。与 Type I 平台一样，虚拟设备通过定期登录来保持与云的连接。通过这种方式，攻击者使用虚拟设备秘密地替代了 Alice 的真实设备。<br>攻击后果：隐私泄露，在正常操作中，当 Alice 使用她的移动应用程序向云端发送远程控制命令时，云端会转发该命令到设备。然而，在远程替换中，真实设备已被虚拟设备取代，由攻击者控制。结果，来自 Alice 的所有控制命令都暴露给了虚拟设备。例如以智能插头为例，Trudy可以知道 Alice 什么时候打开&#x2F;关闭智能插头。该信息可用于推断爱丽丝是否在家。<br>攻击后果：伪造数据，在正常操作中，真实设备将其传感器读数更新到云端，结果反映在 Alice 的移动应用程序中。然而，在远程替换攻击中，传感器读数从虚拟设备发送。这给了 Trudy 一个操纵发送给 Alice 的传感器读数的机会，从而欺骗或误导Alice。例如，实验测试了一个小米烟雾报警器（model: Fire Alarm Detector）和一个Alink智能锁（model: KAADAS KDSLOCK001)。如果烟雾报警器检测到房间内浓烟，智能锁将自动解锁以打开窗门。实验使用远程设备替换攻击来操纵烟雾报警器的传感器读数并成功解锁了智能锁，这会导致严重的后果，因为Trudy可以随意进入Alice的房间。</p><h3 id="6-2远程设备-DoS"><a href="#6-2远程设备-DoS" class="headerlink" title="6.2远程设备 DoS"></a>6.2远程设备 DoS</h3><p>作为一项基本的安全措施，物联网云应该只允许授权用户控制设备。如果攻击者可以解除绑定合法用户的目标设备，导致合法用户无法再操作设备，本质上导致设备拒绝服务 (DoS) 攻击。为了发动这种攻击，攻击者不需要利用很多缺陷，特别是对于 I 型平台，在攻击者发送设备端解除绑定命令后（step T.3），如图Figure 5，直接请求云撤销受害用户与用户之间的设备绑定关系。对于Type II平台，如图Figure 6所示，攻击者利用F1.2漏洞将攻击者账户绑定到受害者设备。</p><h3 id="6-3非法占用设备"><a href="#6-3非法占用设备" class="headerlink" title="6.3非法占用设备"></a>6.3非法占用设备</h3><p>虽然一个设备可以与多个用户共享，但只有一个用户账号可以绑定一个智能家居设备。如果攻击者可以预测未出售的设备 ID设备并使用脚本将它们与有攻击者账户绑定，这些设备售出后无法再次绑定，我们称这种攻击为非法设备占用。本质上，这种攻击使合法消费者无法使用新设备。此攻击仅适用于 Type I 平台，因为攻击者可以预测设备身份信息。在 Type II 平台中，硬编码在设备中的ID是长且不易预测的，这类设备flash中一般会预留一个分区来存储硬编码的设备ID或证书密钥，比如类似于下图这个flash分区，设备出厂前在factory分区烧录了硬编码信息，设备ID或证书密钥，且每台设备都不一样，很难做到批量预测其他设备硬编码信息。</p><p><img src="/2022/11/27/%E6%B5%85%E8%B0%88%E6%99%BA%E8%83%BD%E7%89%A9%E8%81%94%E7%BD%91%E5%AE%B6%E5%B1%85%E5%B9%B3%E5%8F%B0%E5%AE%89%E5%85%A8%E9%9A%90%E6%82%A3/image-20221114115317544.png" alt="image-20221114115317544"></p><h3 id="6-4-水平越权"><a href="#6-4-水平越权" class="headerlink" title="6.4 水平越权"></a>6.4 水平越权</h3><p>论文中并没单独来说水平越权的漏洞，实际上存在不少物联网云API权限校验不严格导致的水平越权风险。以某智能摄像机举例，移动应用APP配置摄像机连接WIFI，绑定摄像机，摄像机上线后可以通过APP远程控制摄像机，执行摄像机转向、升级、开关、定时等操作。通过中间人攻击抓取这些控制指令，分析发现物联网云对API做权限校验是通过检查请求中包含的用户cookie和请求体中的sn(设备序列号)参数，权限校验通过后将指令下发到设备，但安全测试中发现某些API漏掉了权限校验，导致通过篡改请求中的sn参数实现对未绑定设备的远程控制，一般来说，同一型号设备的sn码都是厂商按一定规律生成的，可被暴力遍历。</p><h2 id="0x07-缓解措施"><a href="#0x07-缓解措施" class="headerlink" title="0x07.缓解措施"></a>0x07.缓解措施</h2><h3 id="7-1-严格的设备认证"><a href="#7-1-严格的设备认证" class="headerlink" title="7.1 严格的设备认证"></a>7.1 严格的设备认证</h3><p>为确保每一个与物联网云通信的设备是真正的设备，建议制造商嵌入唯一的客户端证书。此外，物联网云应该始终在接受任何设备请求之前检查客户端证书。因为物联网云使用设备 ID 来识别设备，建议平台提供商改造设备 ID 分发机制使攻击者无法轻易获得有效的设备ID。硬编码设备ID 是一种不好的做法，因为一旦设备 ID 泄露，相应的设备将永远易受攻击。</p><h3 id="7-2-综合授权检查"><a href="#7-2-综合授权检查" class="headerlink" title="7.2 综合授权检查"></a>7.2 综合授权检查</h3><p>与移动端请求指令相比，实验发现大多数物联网云对设备端指令不强制执行严格的授权检查。对于 I 型平台，当设备与物联网云连接，用户账户信息不存在设备，因此，物联网云直接接受未经授权的登录 (F3) 或取消绑定 (F4) 命令。对于 II 型平台，由于设备负责检查绑定关系，云端跳过进一步授权检查。建议设备和物联网云存储并保持绑定关系以及执行授权检查。此外，在云端，每个设备端请求都应做基于账户的身份验证，尤其是对于关键操作，例如设备登录，设备必须明确包含每次登录的用户凭据要求。这种额外的凭据检查可防止目标设备重新连接到云。</p><h3 id="7-3-强制状态转换的有效性"><a href="#7-3-强制状态转换的有效性" class="headerlink" title="7.3 强制状态转换的有效性"></a>7.3 强制状态转换的有效性</h3><p>论文实验中所有测试的平台都未能强制执行所涉及的状态转换的有效性。为了为防止攻击者利用意外的状态转换，智能家居平台应识别并制定每个合法的交互请求，以 3 元组形式呈现（sender entity &amp; its state, the request message, receiver entity &amp; its state）。除了检查每个请求之外，发送方实体还应验证其当前状态是否允许请求发出；接收方实体应核实是否允许其当前状态接收请求。例如，图 Figure2 所示的物联网云应该只接受当它停留在状态1时的设备注册请求。同时，平台的物联网云应该同步三个实体，使它们保持在一个合法的状态组合。最后，如果出现不可恢复的系统错误时，三个实体应该立即回滚到它们的初始状态。</p><h2 id="0x08-总结"><a href="#0x08-总结" class="headerlink" title="0x08.总结"></a>0x08.总结</h2><p>这篇论文从物联网设备、移动应用程序和物联网云三者交互角度评估了物联网智能家居平台的安全隐患，给我们展现了一些有意思的攻击面，最后讲述了攻击手段和漏洞缓解措施。想了解更详细的信息建议阅读论文原文。</p><h2 id="0x09-参考"><a href="#0x09-参考" class="headerlink" title="0x09.参考"></a>0x09.参考</h2><p>论文原文链接：<a href="https://www.usenix.org/system/files/sec19-zhou.pdf">https://www.usenix.org/system/files/sec19-zhou.pdf</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01.简介&quot;&gt;&lt;/a&gt;0x01.简介&lt;/h2&gt;&lt;p&gt;随着物联网云的兴起，越来越多的智能设备接入了云。现在人们可以随时随地拿起手机，打开APP远程控制家里</summary>
      
    
    
    
    
    <category term="sec" scheme="http://example.com/tags/sec/"/>
    
    <category term="IoT sec" scheme="http://example.com/tags/IoT-sec/"/>
    
  </entry>
  
  <entry>
    <title>用uboot操控某路由器设备</title>
    <link href="http://example.com/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/"/>
    <id>http://example.com/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/</id>
    <published>2022-06-29T01:29:30.000Z</published>
    <updated>2023-03-28T06:34:38.389Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-从uart-进入uboot-shell"><a href="#0x01-从uart-进入uboot-shell" class="headerlink" title="0x01.从uart 进入uboot shell"></a>0x01.从uart 进入uboot shell</h2><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220324181647725.png" alt="image-20220324181647725"></p><p>某路由器设备拆开后找到了uart接口，将uart引脚通过TTL接入到电脑，路由器上电启动，观察启动日志.</p><pre><code class="shell">Boot SPI NANDstart read bootheaderstart read secondbootnon secure boot Jumpddr init enter, rate is 1333 mbpsddr size is 0x10000000U-Boot 2013.04 (Feb 14 2022 - 16:16:39)......eth0Hit 1 to upgrade software versionHit any key to stop autoboot:  1 ......*****************pc start*************************************echo 5000 &gt; /proc/sys/vm/min_free_kbytes********************close console </code></pre><p>从上面设备的部分启动日志可以看出，uboot shell可以被中断，路由器上电后快速按任意键可进入；路由器启动后关闭了console 控制台，不能通过console登录路由器。为了方便后续逆向工作，我们想要进入路由器系统，但目前是console已关闭，且未发现telnet、ssh等服务，只能从uboot shell为切入点进一步分析。</p><p>路由器reset，快速按下任意键进入boot shell，可以看到当前uboot shell支持的命令</p><pre><code class="shell">=&gt; h?       - alias for &#39;help&#39;base    - print or set address offsetbdinfo  - print Board Info structureboot    - boot default, i.e., run &#39;bootcmd&#39;bootd   - boot default, i.e., run &#39;bootcmd&#39;bootk   - boot kernelbootm   - boot application image from memorybootz   - boot Linux zImage image from memorycmp     - memory compareconinfo - print console devices and informationcp      - memory copydhcp    - boot image via network using DHCP/TFTP protocoldownver - upgrade software downloaded from TFTP serverecho    - echo args to consoleerase   - erase FLASH memoryfdt     - flattened device tree utility commandsflinfo  - print FLASH memory informationgo      - start application at address &#39;addr&#39;gpiotest- gpiotest dir [num] [in/out]gpiotest value [num] [1/0]gpiotest gvalue [num]help    - print command description/usageimxtract- extract a part of a multi-imageitest   - return true/false on integer comparemcupg   -  multicast upgrademd      - memory displaymii     - MII utility commandsmtddebug- mtddebug operatemtest   - simple RAM read/write testmw      - memory write (fill)nand    - NAND sub-systemping    - send ICMP ECHO_REQUEST to network hostprintenv- print environment variablesprotect - enable or disable FLASH write protectionreset   - Perform RESET of the CPUrun     - run commands in an environment variablesaveenv - save environment variables to persistent storagesetenv  - set environment variablessleep   - delay execution for some timesnumber - Get or set serial number for zte boardstftp    - boot image via network using TFTP protocolversion - print monitor, compiler and linker versionwatchdog- watchdog reset &amp;&amp; disablexmodem  - xmodem</code></pre><h2 id="0x02-修改内核启动参数"><a href="#0x02-修改内核启动参数" class="headerlink" title="0x02.修改内核启动参数"></a>0x02.修改内核启动参数</h2><p>printenv查看当前环境变量</p><pre><code class="shell">=&gt; printenvbaudrate=115200bome=aclcle) root=/dev/mtdblock8 rw rootfstype=jffs2 mem=256M singlebootcmd=setenv bootargs console=$(console) root=/dev/mtdblock8 ro rootfstype=jffs2  mem=$(memsize);bootm 0x440001e0;bootdelay=1bootfile=uboot.binbootloaderfile=bootloader.binconsole=ttyAMA0,115200n8ethact=eth0ethaddr=00:41:71:00:00:50fileaddr=44000000filesize=13bfb78gatewayip=192.168.1.1ipaddr=192.168.1.1linuzfile=vmlinuz.binloadaddr=0x44000000memsize=256Mnand_erasesize=20000nand_oobsize=40nand_writesize=800netmask=255.255.255.0netretry=5serverip=192.168.1.100</code></pre><p>bootargs为内核启动参数，这里没有看到init参数，一般来说，通过设置init参数来指定内核启动后第一个执行的脚本，可以尝试设置init&#x3D;&#x2F;bin&#x2F;sh进入linux shell。</p><pre><code class="shell">setenv bootcmd &#39;setenv bootargs console=$(console) root=/dev/mtdblock8 rw rootfstype=jffs2  mem=$(memsize) init=/bin/sh;bootm 0x440001e0;&#39;</code></pre><p>用setenv修改bootcmd参数，保存环境变量。</p><pre><code class="shell">=&gt; saveSaving Environment to NAND...Erasing 0x180000 - 0x200000:&lt;nand_erase_skip_bad_,1560&gt;!mtdpart=0x1,start=0x0,mtdpartoffset=0x180000,mtdPartsize=0x80000,length=0x80000        [Done]Writing to Nand:&lt;nand_write_skip_bad_,1455&gt;!mtdpart=0x1,offset=0x0,mtdpartoffset=0x180000,mtdPartsize=0x80000,length=0x20000        [Done]</code></pre><p>bootm启动发现失败，这里报错<code>can&#39;t get kernel image!</code></p><pre><code class="shell">=&gt; bootm 0x440001e0Wrong Image Format for bootm commandERROR: can&#39;t get kernel image!</code></pre><p>下载一份u-boot-2013源码，搜索<code>can&#39;t get kernel image</code>字符串，定位到关键代码。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220406180230602.png" alt="image-20220406180230602"></p><p>uboot首先会检测kernel的uimage头部信息，不正确会输出上面错误。kernel uimage是在kernel image前加上一段长度为64字节的头，用于描述内核的版本、加载位置等信息 ，uimage魔数一般是0x27051956，很明显0x440001e0地址的数据不符合，所以加载报错。</p><pre><code class="c">typedef struct image_header &#123;    __be32ih_magic;/* Image Header Magic Number*/    __be32ih_hcrc;/* Image Header CRC Checksum*/    __be32ih_time;/* Image Creation Timestamp*/    __be32ih_size;/* Image Data Size*/    __be32ih_load;/* Data Load  Address*/    __be32ih_ep;/* Entry Point Address*/    __be32ih_dcrc;/* Image Data CRC Checksum*/    uint8_tih_os;/* Operating System*/    uint8_tih_arch;/* CPU architecture*/    uint8_tih_type;/* Image Type*/    uint8_tih_comp;/* Compression Type*/    uint8_tih_name[IH_NMLEN];/* Image Name*/&#125; image_header_t;#define IH_MAGIC0x27051956/* Image Magic Number*/#define IH_NMLEN32/* Image Name Length*/</code></pre><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220406180611516.png" alt="image-20220406180611516"></p><pre><code class="shell">=&gt; md.b 440001e0 100440001e0: ff d7 ff ff bf fe fd f7 7f ff 7f df 5f bd ff ff    ............_...440001f0: f6 a2 b7 f7 5f fe fe fe 77 f5 db ff 3f bf fa 76    ...._...w...?..v44000200: fc ed ef fd 7f ff ff fd 7b ee ff ee fd 7b ff 75    ........&#123;....&#123;.u44000210: 67 7d e8 bf ee ef ed a1 cd fb 63 fe 67 ee f7 9e    g&#125;........c.g...44000220: f3 df af f5 ea ff f7 fb 78 77 ea fd df ff ef fb    ........xw......44000230: d3 dd e9 ff b3 3f e7 ef 76 f6 f6 ed cf b3 bd fb    .....?..v.......44000240: bf eb 97 fb 9f ef ff ef d9 59 b9 3e 5f 3f ff 32    .........Y.&gt;_?.2</code></pre><p>正常情况下0x440001e0地址应该存放着kernel的uimage数据，这里不知什么原因kernel uimage未能正确加载到内存。既然内核未能正常加载到内存，那就尝试从手动从nand flash中读取内核到内存中。</p><pre><code class="shell">0x000000000000-0x000008000000 : &quot;whole flash&quot;0x000000000000-0x000000200000 : &quot;u-boot&quot;0x000006800000-0x000006b00000 : &quot;parameter tags&quot;0x000000200000-0x000000700000 : &quot;kernel0&quot;0x000000700000-0x000000c00000 : &quot;kernel1&quot;0x000000c00000-0x000001400000 : &quot;usercfg&quot;0x000001400000-0x000001500000 : &quot;others&quot;0x000001500000-0x000001800000 : &quot;wlan&quot;0x000001800000-0x000003800000 : &quot;rootfs0&quot;0x000003800000-0x000005800000 : &quot;rootfs1&quot;0x000005800000-0x000006000000 : &quot;framework&quot;0x000006000000-0x000006800000 : &quot;framework1&quot;0x000006b00000-0x000008000000 : &quot;apps&quot;</code></pre><p>路由器正常启动的日志中，可以看到nand flash的13个分区，其中0x000000200000-0x000000700000 、0x000000700000-0x000000c00000存放这kernel数据，其中一个应该是做备份用。</p><p>nand dump查看nand flash中内核数据，uimage从0x2001e0开始</p><pre><code class="shell">=&gt; nand dump 0x200000Page 00200000 dump:    99 99 99 99 44 44 44 44  55 55 55 55 aa aa aa aa    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 00 00 56 31 2e 30  2e 31 2e 32 32 30 33 31    35 2e 31 37 30 39 33 33  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    01 00 00 00 00 5a 64 01  17 58 24 00 e0 01 00 00    dc e0 50 82 00 00 3c 01  00 5a 24 00 d2 2c 67 09    00 00 20 00 00 00 50 00  00 00 80 01 00 00 00 02    00 00 70 00 00 00 50 00  00 00 80 03 00 00 00 02    5a 58 49 43 20 33 36 30  54 36 47 56 32 20 55 4e    49 20 56 31 2e 30 2e 31  2e 32 32 30 33 31 35 2e    31 37 30 39 33 33 00 00  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00    00 00 04 00 00 5a 60 01  31 52 b8 ea 56 32 5f 56    32 2e 00 00 00 00 00 00  00 00 00 00 00 00 00 00    01 00 00 00 47 9b 29 1d  32 30 32 32 30 33 32 31    31 38 32 35 32 31 00 00  00 00 00 00 ff ff ff ff    ff ff ff ff 00 00 00 10  ff ff 01 00 56 31 2e 30    00 00 00 00 00 00 00 00  00 00 00 00 33 36 30 54    36 47 56 32 00 00 00 00  00 00 00 00 15 56 24 56    5a 58 30 31 03 30 00 00  00 e0 00 02 43 57 46 57    31 37 30 33 32 38 31 30  30 31 00 00 ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    ff ff ff ff ff ff ff ff  ff ff ff ff ff ff ff ff    27 05 19 56 3c 35 3b 72  62 38 52 83 00 24 57 d7    40 00 80 00 40 00 80 00  cc 1f fd e3 05 02 02 00    4c 69 6e 75 78 20 4b 65  72 6e 65 6c 20 49 6d 61</code></pre><p>使用nand read将nand flash中kernel分区数据加载到内存中，addr是ram的地址，off指的是nand flash的地址， size指要读取nand flash的数据大小。</p><pre><code class="shell">nand read - addr off|partition size=&gt;nand read 0x44000000 0x200000 500000NAND read: device 0 offset 0x200000, size 0x500000 5242880 bytes read: OK=&gt; md.b 0x440001e0 60440001e0: 27 05 19 56 3c 35 3b 72 62 38 52 83 00 24 57 d7    &#39;..V&lt;5;rb8R..$W.440001f0: 40 00 80 00 40 00 80 00 cc 1f fd e3 05 02 02 00    @...@...........44000200: 4c 69 6e 75 78 20 4b 65 72 6e 65 6c 20 49 6d 61    Linux Kernel Ima44000210: 67 65 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ge..............44000220: 00 00 a0 e1 00 00 a0 e1 00 00 a0 e1 00 00 a0 e1    ................44000230: 00 00 a0 e1 00 00 a0 e1 00 00 a0 e1 00 00 a0 e1    ................</code></pre><pre><code class="shell">=&gt; bootm 0x440001e0## Booting kernel from Legacy Image at 440001e0 ...   Image Name:   Linux Kernel Image   Image Type:   ARM Linux Kernel Image (uncompressed)   Data Size:    2381783 Bytes = 2.3 MiB   Load Address: 40008000   Entry Point:  40008000   Verifying Checksum ... OK   Loading Kernel Image ... OKOK----------------------|--&gt;setup versioninfo tag...Starting kernel ...</code></pre><p>再次bootm，成功启动，但是当内核尝试启动我们添加的启动参数init&#x3D;&#x2F;bin&#x2F;sh时失败了，未能成功进入linux shell，之后又重新用了默认启动参数重启。</p><pre><code class="shell">Set_Trap_Pkt_Pps_Limit is NULL.Set_Trap_Pkt_Pps_Limit is NULL.VFS: Mounted root (jffs2 filesystem) on device 31:9.Freeing unused kernel memory: 176K (c05b4000 - c05e0000)This architecture does not have kernel memory protection.Kernel panic - not syncing: Requested init /bin/sh; failed (error -2).CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.1.25 #2</code></pre><p>添加init参数未能成功启动，后面尝试修改文件系统，开启console、修改root密码，修改后的文件系统通过tftp上传到设备。</p><h2 id="0x03-uboot-tftp通信环境搭建"><a href="#0x03-uboot-tftp通信环境搭建" class="headerlink" title="0x03.uboot tftp通信环境搭建"></a>0x03.uboot tftp通信环境搭建</h2><p>uboot shell 支持tftp通信功能，这里先在ubuntu 18 PC机上安装tftp服务</p><pre><code class="shell">sudo apt install tftpd-hpa</code></pre><p>检查tftpd-hpa服务是否正在运行</p><pre><code class="shell">sudo systemctl status tftpd-hpa</code></pre><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629095150816.png" alt="image-20220629095150816"></p><p><strong>tftpd-hpa</strong>服务器的默认配置文件是**&#x2F;etc&#x2F;default&#x2F;tftpd-hpa<strong>。</strong>TFTP_DIRECTORY**是TFTP服务器访问目录。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629095659437.png" alt="image-20220629095659437"></p><p>给<strong>TFTP_OPTIONS</strong>选项添加**–create**选项，否则无法创建新文件或将新文件上传到 TFTP 服务器。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629095841941.png" alt="image-20220629095841941"></p><p>修改&#x2F;var&#x2F;lib&#x2F;tftpboot访问属性</p><pre><code class="shell">chmod 777 /var/lib/tftpboot</code></pre><p>uboot shell环境变量中tftp的 serverip默认为192.168.1.100，这里我们直接将上面装有tftp服务器的ubuntu的ip地址设为192.168.1.100，</p><p>pc与路由器通过网线连接，尝试从tftp服务器下载个测试文件app.cgi到uboot，至此tftp通信环境已建立，下面修改文件系统上传到uboot。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220330112532398.png" alt="image-20220330112532398"></p><h2 id="0x04-修改文件系统进入linux-shell"><a href="#0x04-修改文件系统进入linux-shell" class="headerlink" title="0x04.修改文件系统进入linux shell"></a>0x04.修改文件系统进入linux shell</h2><p>已经从网上下载到了设备固件，另外通过uboot也可以从flash的rootfs分区dump出文件系统。当前想通过修改固件开启console并修改登录密码，修改后的固件重新打包通过tftp上传到uboot，最后在刷到nand flash的文件系统分区。</p><p>前面了解到路由器正常启动时，串口日志最后打印了<code>close console</code>，可见根文件系统启动后直接关闭了console，导致不能通过串口登录到linux shell。解包设备固件，在程序中搜索<code>close console</code>字符串，发现该字符串出现在<code>/bin/cspd</code>程序中。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629102259170.png" alt="image-20220629102259170"></p><p>找到关闭console的代码，直接patch掉。开启console后想要登录进linux shell还需要知道用户名、密码，可以考虑直接将&#x2F;etc&#x2F;passwd文件中root用户密码字段置空，后面登录时直接输入用户名root即可登录。</p><p>从上面的环境变量信息可以知道设备使用的是jffs2文件系统，将上面修改后的文件重新打包为jffs2格式，打包后的文件系统通过tftp下载到uboot，此时文件系统还只是在RAM中，断电或者重启后数据就会丢失，所以后面还需要将RAM中的文件系统数据用nand write命令写入到nand flash的文件系统分区。</p><pre><code class="shell">mkfs.jffs2 -d ./fs_1/ -l -e 0x20000 -o jffs2.img --no-cleanmarkers</code></pre><p>通过上面步骤将修改后的文件系统刷入 nand flash文件系统分区后，重启设备，成功开启console，进入linux shell。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629104835132.png" alt="image-20220629104835132"></p><h2 id="0x05-telnet-server-移植"><a href="#0x05-telnet-server-移植" class="headerlink" title="0x05.telnet server 移植"></a>0x05.telnet server 移植</h2><p>上面通过修改文件系统实现了从本地console进入到linux shell。设备默认没有telnet服务，为了方便后续管理设备，考虑移植个telnet server到设备中。</p><p>查看固件中程序信息,发现使用buildroot编译，所以尝试使用Buidroot 2017.05编译一个带有telnetd的busybox移植到设备。</p><pre><code class="shell">objdump -s --section=.comment Simulator</code></pre><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110336001.png" alt="image-20220629110336001"></p><p><a href="https://buildroot.org/downloads/">https://buildroot.org/downloads/</a> 下载buildroot 2017.05版本</p><pre><code class="shell">make menuconfig</code></pre><p>进入编译配置界面</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110505003.png" alt="image-20220629110505003"></p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110531814.png" alt="image-20220629110531814"></p><p>配置界面选项主要根据下图固件中文件的信息，ARM 、ELF32、LSB、EABI5 等配置，ld-linux.so.3说明用的是glibc库 。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110607230.png" alt="image-20220629110607230"></p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110717800.png" alt="image-20220629110717800"></p><p>接着设置busybox相关选项，添加telnetd</p><pre><code class="shell">make busybox-menuconfig</code></pre><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629110753723.png" alt="image-20220629110753723"></p><p>以上设置完成后执行<code>make</code>进行编译，编译完成后在当前目录会生成output文件夹，编译好的busybox在output文件夹中，生成的telnetd是链接到busybox的，所以这里直接将生成的busybox移植到路由器即可。将编译的busybox复制到固件文件系统&#x2F;bin目录并重命名为busybox2</p><p>在路由器文件系统自启动目录&#x2F;etc&#x2F;rcS.d下找个文件，加入busybox2 telnetd的启动命令</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220413185728443.png" alt="image-20220413185728443"></p><p>上面修改完成后，重新将文件打包成jffs2文件系统，然后通过tftp下载到uboot，最后nand write写入到nand flash文件系统，重启设备，telnet服务会自动启动，通过telnet客户端成功连接到路由器，后续动态调试移植gdbserver也可使用类似方法。</p><p><img src="/2022/06/29/%E7%94%A8uboot%E6%93%8D%E6%8E%A7%E6%9F%90%E8%B7%AF%E7%94%B1%E5%99%A8%E8%AE%BE%E5%A4%87/image-20220629111625298.png" alt="image-20220629111625298"></p><h2 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06.总结"></a>0x06.总结</h2><p>通过uart打断uboot进入uboot shell，给内核启动参数添加init未能成功启动；根据启动日志搜索关键字符串定位到关闭console的程序，patch二进制程序开启console，修改root密码，将修改后的文件重新打包通过tftp下载到uboot中，最后使用nand write写入到nand flash文件系统分区，实现从本地console进入到linux shell。最后使用Buidroot编译一个带有telnetd的busybox移植到设备，实现telnet登录到设备。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-从uart-进入uboot-shell&quot;&gt;&lt;a href=&quot;#0x01-从uart-进入uboot-shell&quot; class=&quot;headerlink&quot; title=&quot;0x01.从uart 进入uboot shell&quot;&gt;&lt;/a&gt;0x01.从uart 进入u</summary>
      
    
    
    
    
    <category term="sec" scheme="http://example.com/tags/sec/"/>
    
    <category term="IoT sec" scheme="http://example.com/tags/IoT-sec/"/>
    
  </entry>
  
  <entry>
    <title>buildroot构建mips32调试环境</title>
    <link href="http://example.com/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/"/>
    <id>http://example.com/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/</id>
    <published>2021-03-20T01:29:30.000Z</published>
    <updated>2023-03-28T02:18:45.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-编译配置"><a href="#0x01-编译配置" class="headerlink" title="0x01.编译配置"></a>0x01.编译配置</h2><p>使用buildroot可构建uboot，内核，根文件系统等。</p><p>可直接下载解压链接：<a href="https://buildroot.org/download.html">https://buildroot.org/download.html</a></p><pre><code class="shell"># 安装依赖库$ sudo apt-get update$ sudo apt-get install libncurses5-dev patch # 下载源码$ git clone https://github.com/buildroot/buildroot.git # 进行编译的配置$ cd buildroot</code></pre><p>通过<code>ls configs</code>可以查看支持的一些架构信息</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809185516849.png" alt="image-20210809185516849"></p><p>这些config可以生成qemu用的vmlinux还有rootfs，这里我们的目的是生成mips64为的qemu镜像，键入命令</p><pre><code class="shell">make qemu_mips32r2_malta_defconfig</code></pre><p>接着执行</p><pre><code class="shell">make menuconfig</code></pre><p>选择更具体的编译选项。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809195839676.png" alt="image-20210809195839676"></p><p>Toolchain 的选择：</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809200858241.png" alt="image-20210809200858241"></p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809200929756.png" alt="image-20210809200929756"></p><p>Target packahges选项。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809201338793.png" alt="image-20210809201338793"></p><p>在 <code>Debugging, profiling and benchmark</code>中勾选<code>dt</code>和<code>starce</code>、<code>gdb</code></p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809201722695.png" alt="image-20210809201722695"></p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809201757257.png" alt="image-20210809201757257"></p><p>在<code>&gt; Target packages &gt; Networking applications</code>中选中<code>netcat</code> <code>nmap</code> <code>ncat</code> <code>openssh</code></p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210809202051415.png" alt="image-20210809202051415"></p><p>之后save退出,make开始编译。</p><pre><code class="shell">make</code></pre><p>编译完成后可以在output-&gt;images文件夹下看到编译好的内核、文件系统、启动脚本。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810121656958.png" alt="image-20210810121656958"></p><h2 id="0x02-mips系统网络配置"><a href="#0x02-mips系统网络配置" class="headerlink" title="0x02.mips系统网络配置"></a>0x02.mips系统网络配置</h2><p>使用qemu模拟mips系统前，先在ubuntu系统做如下操作</p><p>1.获取安装依赖文件</p><pre><code class="shell">sudo apt-get install uml-utilities bridge-utils</code></pre><p>2.修改Ubuntu 主机网络配置。将Ubuntu系统中网络接口配置文件&#x2F;etc&#x2F;network&#x2F;interfaces 修改为如下内容并保存。</p><pre><code class="shell">auto loiface lo inet loopbackauto ens33iface ens33 inet dhcpauto br0iface br0 inet dhcp bridge_ports ens33 bridge_maxwait 0</code></pre><p>3.创建qemu网络接口启动脚本，重启网络使配置生效。使用如下命令创建并编辑&#x2F;etc&#x2F;qemu-ifup 文件</p><pre><code class="shell">echo &quot;Executing /etc/qemu-ifup&quot;echo &quot;Bringing $1 for bridged mode ...&quot;sudo /sbin/ifconfig $1 0.0.0.0 promisc upecho &quot;Adding $1 to br0...&quot;sudo /sbin/brctl addif br0 $1sleep 3</code></pre><p>保存文件后，使用如下命令修改qemu-ifup权限，重启网络使所有配置生效。</p><pre><code class="shell">sudo chmod 777 /etc/qemu-ifupsudo /etc/init.d/networking restart</code></pre><p>4.启动桥接网络</p><pre><code class="shell">sudo ifdown eth0sudo ifup br0</code></pre><p>5.将start-qemu.sh启动脚本修改为如下内容。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810163309812.png" alt="image-20210810163309812"></p><p>原文件内容</p><pre><code class="shell">#!/bin/sh(BINARIES_DIR=&quot;$&#123;0%/*&#125;/&quot;cd $&#123;BINARIES_DIR&#125;if [ &quot;$&#123;1&#125;&quot; = &quot;serial-only&quot; ]; then    EXTRA_ARGS=&#39;-nographic&#39;else    EXTRA_ARGS=&#39;-serial stdio&#39;fiexport PATH=&quot;/home/tangle/Desktop/buildroot-2021.05/output/host/bin:$&#123;PATH&#125;&quot;exec qemu-system-mips -M malta -kernel vmlinux  -drive file=rootfs.ext2,format=raw -append &quot;rootwait root=/dev/hda&quot; -net nic,model=pcnet -net user  $&#123;EXTRA_ARGS&#125;)</code></pre><p>修改后：</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810163239855.png" alt="image-20210810163239855"></p><p>启动脚本</p><pre><code class="shell">sudo ./start-qemu.sh</code></pre><p>发现如下报错</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810164054901.png" alt="image-20210810164054901"></p><p>说明qemu默认启动qemu-ifup脚本是到<code>/home/tangle/Desktop/buildroot-2021.05/output/host/bin/../etc/qemu-ifup</code></p><p>这个目录下寻找，而上面是在<code>/etc/qemu-ifup</code> 目录下创建的，所以将<code>/etc/qemu-ifup</code>复制到<code>/home/tangle/Desktop/buildroot-2021.05/output/host/bin/../etc/qemu-ifup</code>即可。</p><p>修改后重新启动脚本进入mips系统。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810165053184.png" alt="image-20210810165053184"></p><p>给eth0网卡设置ip，ubuntu系统ip是<code>192.168.2.131</code></p><pre><code class="shell">ifconfig eth0 192.168.2.111</code></pre><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810192746557.png" alt="image-20210810192746557"></p><p>测试和ubuntu系统的通信。</p><p><img src="/2021/03/20/buildroot%E6%9E%84%E5%BB%BAmips32%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83/image-20210810192937951.png" alt="image-20210810192937951"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;0x01-编译配置&quot;&gt;&lt;a href=&quot;#0x01-编译配置&quot; class=&quot;headerlink&quot; title=&quot;0x01.编译配置&quot;&gt;&lt;/a&gt;0x01.编译配置&lt;/h2&gt;&lt;p&gt;使用buildroot可构建uboot，内核，根文件系统等。&lt;/p&gt;
&lt;p&gt;可直接下</summary>
      
    
    
    
    
    <category term="sec" scheme="http://example.com/tags/sec/"/>
    
    <category term="IoT sec" scheme="http://example.com/tags/IoT-sec/"/>
    
  </entry>
  
</feed>
